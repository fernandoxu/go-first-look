# 方法设计

## 方法集合与如何选择 receiver 类型

```go
func (t T) M1() <=> F1(t T)
func (t *T) M2() <=> F2(t *T)
```

- 当 receiver 参数的类型为 T 时，传入的是**T类型实例的副本**，在 F1 函数的实现中对参数 t 做任何修改，都只会影响副本，而不会影响到原 T 类型实例。
- 当 receiver 参数的类型为 *T 时，传入的是**T类型实例的地址**，在 F2 函数的实现中对参数 t 做任何修改，都会反映到原 T 类型实例上。

```go
package main

type T struct {
    a int
}

func (t T) M1() {
    t.a = 1
}

func (t *T) M2() {
    t.a = 2
}

func main () {
  var t T
  println(t.a) // 0

  t.M1()
  println(t.a) // 0

  p := &t
  p.M2()
  println(t.a) // 2
}
```

> 无论是 `T` 类型实例，还是`*T` 类型实例，都既可以调用 receiver 为 `T` 类型的方法，也可以调用 receiver 为`*T` 类型的方法。

```go
  type T struct {
      a int
  }
  
  func (t T) M1() {
      t.a = 10
  }
 
 func (t *T) M2() {
     t.a = 11
 }
 
 func main() {
     var t1 T
     println(t1.a) // 0
     t1.M1()
     println(t1.a) // 0
     t1.M2()
     println(t1.a) // 11
 
     var t2 = &T{}
     println(t2.a) // 0
     t2.M1()
     println(t2.a) // 0
     t2.M2()
     println(t2.a) // 11
 }
```

### 原则

1. 要在方法中对 receiver 参数代表的类型实例进行修改，选择 *T 类型
2. 不需要修改一般选择 T 类型。特殊情况：`如果 receiver 参数类型的 size 较大，以值拷贝形式传入就会导致较大的性能开销，这时选择 *T 作为 receiver 类型可能更好些`

### 方法集合

> 方法集合是用来判断一个类型是否实现了某接口类型的唯一手段，可以说，“方法集合决定了接口实现”。
>
>Go 中任何一个类型都有属于自己的方法集合，或者说方法集合是 Go 类型的一个“属性”。但不是所有类型都有自己的方法呀，比如 int 类型就没有。所以，对于没有定义方法的 Go 类型，我们称其拥有空方法集合。接口类型相对特殊，它只会列出代表接口的方法列表，不会具体定义某个方法，它的方法集合就是它的方法列表中的所有方法，可以一目了然地看到。
>
>Go 语言规定，`*T` 类型的方法集合包含所有以`*T` 为 receiver 参数类型的方法，以及所有以 `T` 为 receiver 参数类型的方法。
>
>如果 T 类型需要实现某个接口，那就要使用 T 作为 receiver 参数的类型，来满足接口类型方法集合中的所有方法。如果 T 不需要实现某一接口，但 `*T` 需要实现该接口，那么根据方法集合概念，`*T` 的方法集合是包含 T 的方法集合的，这样我们在确定 Go 方法的 receiver 的类型时，参考原则一和原则二就可以了

#### TODO: 方法集合深入
